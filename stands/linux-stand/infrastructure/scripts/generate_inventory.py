#!/usr/bin/env python3
import argparse
import json
import os
import subprocess
import sys


def run_terraform_output(tf_dir: str) -> dict:
    try:
        result = subprocess.run(
            ["terraform", "output", "-json"],
            cwd=tf_dir,
            check=True,
            capture_output=True,
            text=True,
        )
    except FileNotFoundError:
        raise RuntimeError("terraform not found in PATH")
    except subprocess.CalledProcessError as exc:
        stderr = (exc.stderr or "").strip()
        raise RuntimeError(f"terraform output failed in {tf_dir}: {stderr}")
    try:
        return json.loads(result.stdout or "{}")
    except json.JSONDecodeError as exc:
        raise RuntimeError(f"failed to parse terraform output JSON in {tf_dir}: {exc}")


def get_output(outputs: dict, key: str) -> str:
    if key not in outputs:
        raise RuntimeError(f"missing terraform output: {key}")
    value = outputs[key].get("value")
    if isinstance(value, list):
        return str(value[0]) if value else ""
    return str(value)


def get_output_optional(outputs: dict, key: str) -> str:
    if key not in outputs:
        return ""
    value = outputs[key].get("value")
    if isinstance(value, list):
        return str(value[0]) if value else ""
    return str(value) if value is not None else ""


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate Ansible inventory from Terraform outputs.")
    parser.add_argument("--linux-ws-dir", required=True)
    parser.add_argument("--linux-server-dir", required=True)
    parser.add_argument("--inventory-path", required=True)
    parser.add_argument("--print-env", action="store_true", help="Print KEY=VALUE lines for shell eval.")
    args = parser.parse_args()

    ansible_user = os.getenv("ANSIBLE_USER", "ansible")
    ansible_key = os.getenv("ANSIBLE_KEY", "~/.ssh/id_ed25519")
    ansible_python = os.getenv("ANSIBLE_PYTHON", "/usr/bin/python3")

    ws_outputs = run_terraform_output(args.linux_ws_dir)
    srv_outputs = run_terraform_output(args.linux_server_dir)

    linux_ws_ip = get_output_optional(ws_outputs, "linux_ws_ssh_ip") or get_output(ws_outputs, "linux_ws_ip")
    linux_server_ip = get_output_optional(srv_outputs, "linux_server_ssh_ip") or get_output(srv_outputs, "linux_server_ip")

    lines = [
        "---",
        "# Auto-generated by generate_inventory.py. Do not edit manually.",
        "",
        "all:",
        "  children:",
        "    linux_workstation:",
        "      hosts:",
        "        linux-ws:",
        f"          ansible_host: {linux_ws_ip}",
        f"          ansible_user: {ansible_user}",
    ]
    if ansible_key:
        lines.append(f"          ansible_ssh_private_key_file: {ansible_key}")
    if ansible_python:
        lines.append(f"          ansible_python_interpreter: {ansible_python}")

    lines += [
        "",
        "    linux_server:",
        "      hosts:",
        "        linux-server:",
        f"          ansible_host: {linux_server_ip}",
        f"          ansible_user: {ansible_user}",
    ]
    if ansible_key:
        lines.append(f"          ansible_ssh_private_key_file: {ansible_key}")
    if ansible_python:
        lines.append(f"          ansible_python_interpreter: {ansible_python}")

    inventory_dir = os.path.dirname(os.path.abspath(args.inventory_path))
    if inventory_dir and not os.path.isdir(inventory_dir):
        os.makedirs(inventory_dir, exist_ok=True)

    with open(args.inventory_path, "w", encoding="utf-8") as fh:
        fh.write("\n".join(lines) + "\n")

    if args.print_env:
        print(f"LINUX_WS_IP={linux_ws_ip}")
        print(f"LINUX_SERVER_IP={linux_server_ip}")

    return 0


if __name__ == "__main__":
    try:
        sys.exit(main())
    except RuntimeError as exc:
        print(f"ERROR: {exc}", file=sys.stderr)
        sys.exit(2)
